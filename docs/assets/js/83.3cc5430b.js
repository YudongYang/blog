(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{440:function(t,s,e){"use strict";e.r(s);var a=e(42),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"how-to-write-custom-syntax"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#how-to-write-custom-syntax"}},[t._v("#")]),t._v(" How to Write Custom Syntax")]),t._v(" "),e("p",[t._v("PostCSS can transform styles in any syntax, and is not limited to just CSS.\nBy writing a custom syntax, you can transform styles in any desired format.")]),t._v(" "),e("p",[t._v("Writing a custom syntax is much harder than writing a PostCSS plugin, but\nit is an awesome adventure.")]),t._v(" "),e("p",[t._v("There are 3 types of PostCSS syntax packages:")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Parser")]),t._v(" to parse input string to node’s tree.")]),t._v(" "),e("li",[e("strong",[t._v("Stringifier")]),t._v(" to generate output string by node’s tree.")]),t._v(" "),e("li",[e("strong",[t._v("Syntax")]),t._v(" contains both parser and stringifier.")])]),t._v(" "),e("h2",{attrs:{id:"syntax"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),e("p",[t._v("A good example of a custom syntax is "),e("a",{attrs:{href:"https://github.com/postcss/postcss-scss",target:"_blank",rel:"noopener noreferrer"}},[t._v("SCSS"),e("OutboundLink")],1),t._v(". Some users may want to transform\nSCSS sources with PostCSS plugins, for example if they need to add vendor\nprefixes or change the property order. So this syntax should output SCSS from\nan SCSS input.")]),t._v(" "),e("p",[t._v("The syntax API is a very simple plain object, with "),e("code",[t._v("parse")]),t._v(" & "),e("code",[t._v("stringify")]),t._v("\nfunctions:")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  parse"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("     "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./parse'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  stringify"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./stringify'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"parser"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parser"}},[t._v("#")]),t._v(" Parser")]),t._v(" "),e("p",[t._v("A good example of a parser is "),e("a",{attrs:{href:"https://github.com/postcss/postcss-safe-parser",target:"_blank",rel:"noopener noreferrer"}},[t._v("Safe Parser"),e("OutboundLink")],1),t._v(", which parses malformed/broken CSS.\nBecause there is no point to generate broken output, this package only provides\na parser.")]),t._v(" "),e("p",[t._v("The parser API is a function which receives a string & returns a "),e("a",{attrs:{href:"http://api.postcss.org/Root.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[t._v("Root")]),e("OutboundLink")],1),t._v(" node.\nThe second argument is a function which receives an object with PostCSS options.")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" postcss "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'postcss'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nmodule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("exports")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("css"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opts")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" root "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" postcss"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("root")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Add other nodes to root")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" root\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h3",{attrs:{id:"main-theory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#main-theory"}},[t._v("#")]),t._v(" Main Theory")]),t._v(" "),e("p",[t._v("There are many books about parsers; but do not worry because CSS syntax is\nvery easy, and so the parser will be much simpler than a programming language\nparser.")]),t._v(" "),e("p",[t._v("The default PostCSS parser contains two steps:")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/tokenize.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tokenizer"),e("OutboundLink")],1),t._v(" which reads input string character by character and builds a\ntokens array. For example, it joins space symbols to a "),e("code",[t._v("['space', '\\n ']")]),t._v("\ntoken, and detects strings to a "),e("code",[t._v("['string', '\"\\\"{\"']")]),t._v(" token.")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/parser.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("Parser"),e("OutboundLink")],1),t._v(" which reads the tokens array, creates node instances and\nbuilds a tree.")])]),t._v(" "),e("h3",{attrs:{id:"performance"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#performance"}},[t._v("#")]),t._v(" Performance")]),t._v(" "),e("p",[t._v("Parsing input is often the most time consuming task in CSS processors. So it\nis very important to have a fast parser.")]),t._v(" "),e("p",[t._v("The main rule of optimization is that there is no performance without a\nbenchmark. You can look at "),e("a",{attrs:{href:"https://github.com/postcss/benchmark",target:"_blank",rel:"noopener noreferrer"}},[t._v("PostCSS benchmarks"),e("OutboundLink")],1),t._v(" to build your own.")]),t._v(" "),e("p",[t._v("Of parsing tasks, the tokenize step will often take the most time, so its\nperformance should be prioritized. Unfortunately, classes, functions and\nhigh level structures can slow down your tokenizer. Be ready to write dirty\ncode with repeated statements. This is why it is difficult to extend the\ndefault "),e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/tokenize.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("PostCSS tokenizer"),e("OutboundLink")],1),t._v("; copy & paste will be a necessary evil.")]),t._v(" "),e("p",[t._v("Second optimization is using character codes instead of strings.")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Slow")]),t._v("\nstring"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fast")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OPEN_CURLY")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `{'")]),t._v("\nstring"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("charCodeAt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OPEN_CURLY")]),t._v("\n")])])]),e("p",[t._v("Third optimization is “fast jumps”. If you find open quotes, you can find\nnext closing quote much faster by "),e("code",[t._v("indexOf")]),t._v(":")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Simple jump")]),t._v("\nnext "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" string"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'\"'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentPosition "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Jump by RegExp")]),t._v("\nregexp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastIndex "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" currentPosion "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\nregexp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("string"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nnext "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" regexp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastIndex\n")])])]),e("p",[t._v("The parser can be a well written class. There is no need in copy-paste and\nhardcore optimization there. You can extend the default "),e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/parser.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("PostCSS parser"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("h3",{attrs:{id:"node-source"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-source"}},[t._v("#")]),t._v(" Node Source")]),t._v(" "),e("p",[t._v("Every node should have "),e("code",[t._v("source")]),t._v(" property to generate correct source map.\nThis property contains "),e("code",[t._v("start")]),t._v(" and "),e("code",[t._v("end")]),t._v(" properties with "),e("code",[t._v("{ line, column }")]),t._v(",\nand "),e("code",[t._v("input")]),t._v(" property with an "),e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/input.es6",target:"_blank",rel:"noopener noreferrer"}},[e("code",[t._v("Input")]),e("OutboundLink")],1),t._v(" instance.")]),t._v(" "),e("p",[t._v("Your tokenizer should save the original position so that you can propagate\nthe values to the parser, to ensure that the source map is correctly updated.")]),t._v(" "),e("h3",{attrs:{id:"raw-values"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#raw-values"}},[t._v("#")]),t._v(" Raw Values")]),t._v(" "),e("p",[t._v("A good PostCSS parser should provide all information (including spaces symbols)\nto generate byte-to-byte equal output. It is not so difficult, but respectful\nfor user input and allow integration smoke tests.")]),t._v(" "),e("p",[t._v("A parser should save all additional symbols to "),e("code",[t._v("node.raws")]),t._v(" object.\nIt is an open structure for you, you can add additional keys.\nFor example, "),e("a",{attrs:{href:"https://github.com/postcss/postcss-scss",target:"_blank",rel:"noopener noreferrer"}},[t._v("SCSS parser"),e("OutboundLink")],1),t._v(" saves comment types ("),e("code",[t._v("/* */")]),t._v(" or "),e("code",[t._v("//")]),t._v(")\nin "),e("code",[t._v("node.raws.inline")]),t._v(".")]),t._v(" "),e("p",[t._v("The default parser cleans CSS values from comments and spaces.\nIt saves the original value with comments to "),e("code",[t._v("node.raws.value.raw")]),t._v(" and uses it,\nif the node value was not changed.")]),t._v(" "),e("h3",{attrs:{id:"tests"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tests"}},[t._v("#")]),t._v(" Tests")]),t._v(" "),e("p",[t._v("Of course, all parsers in the PostCSS ecosystem must have tests.")]),t._v(" "),e("p",[t._v("If your parser just extends CSS syntax (like "),e("a",{attrs:{href:"https://github.com/postcss/postcss-scss",target:"_blank",rel:"noopener noreferrer"}},[t._v("SCSS"),e("OutboundLink")],1),t._v(" or "),e("a",{attrs:{href:"https://github.com/postcss/postcss-safe-parser",target:"_blank",rel:"noopener noreferrer"}},[t._v("Safe Parser"),e("OutboundLink")],1),t._v("),\nyou can use the "),e("a",{attrs:{href:"https://github.com/postcss/postcss-parser-tests",target:"_blank",rel:"noopener noreferrer"}},[t._v("PostCSS Parser Tests"),e("OutboundLink")],1),t._v(". It contains unit & integration tests.")]),t._v(" "),e("h2",{attrs:{id:"stringifier"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stringifier"}},[t._v("#")]),t._v(" Stringifier")]),t._v(" "),e("p",[t._v("A style guide generator is a good example of a stringifier. It generates output\nHTML which contains CSS components. For this use case, a parser isn't necessary,\nso the package should just contain a stringifier.")]),t._v(" "),e("p",[t._v("The Stringifier API is little bit more complicated, than the parser API.\nPostCSS generates a source map, so a stringifier can’t just return a string.\nIt must link every substring with its source node.")]),t._v(" "),e("p",[t._v("A Stringifier is a function which receives "),e("a",{attrs:{href:"http://api.postcss.org/Root.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[t._v("Root")]),e("OutboundLink")],1),t._v(" node and builder callback.\nThen it calls builder with every node’s string and node instance.")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("module"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("exports")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("root"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" builder")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Some magic")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" decl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prop "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("':'")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" decl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("';'")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("builder")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("string"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" decl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Some science")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h3",{attrs:{id:"main-theory-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#main-theory-2"}},[t._v("#")]),t._v(" Main Theory")]),t._v(" "),e("p",[t._v("PostCSS "),e("a",{attrs:{href:"https://github.com/postcss/postcss/blob/master/lib/stringifier.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("default stringifier"),e("OutboundLink")],1),t._v(" is just a class with a method for each node type\nand many methods to detect raw properties.")]),t._v(" "),e("p",[t._v("In most cases it will be enough just to extend this class,\nlike in "),e("a",{attrs:{href:"https://github.com/postcss/postcss-scss/blob/master/lib/scss-stringifier.es6",target:"_blank",rel:"noopener noreferrer"}},[t._v("SCSS stringifier"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("h3",{attrs:{id:"builder-function"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#builder-function"}},[t._v("#")]),t._v(" Builder Function")]),t._v(" "),e("p",[t._v("A builder function will be passed to "),e("code",[t._v("stringify")]),t._v(" function as second argument.\nFor example, the default PostCSS stringifier class saves it\nto "),e("code",[t._v("this.builder")]),t._v(" property.")]),t._v(" "),e("p",[t._v("Builder receives output substring and source node to append this substring\nto the final output.")]),t._v(" "),e("p",[t._v("Some nodes contain other nodes in the middle. For example, a rule has a "),e("code",[t._v("{")]),t._v("\nat the beginning, many declarations inside and a closing "),e("code",[t._v("}")]),t._v(".")]),t._v(" "),e("p",[t._v("For these cases, you should pass a third argument to builder function:\n"),e("code",[t._v("'start'")]),t._v(" or "),e("code",[t._v("'end'")]),t._v(" string:")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("builder")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("selector "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'start'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Stringify declarations inside")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("builder")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'}'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rule"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'end'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h3",{attrs:{id:"raw-values-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#raw-values-2"}},[t._v("#")]),t._v(" Raw Values")]),t._v(" "),e("p",[t._v("A good PostCSS custom syntax saves all symbols and provide byte-to-byte equal\noutput if there were no changes.")]),t._v(" "),e("p",[t._v("This is why every node has "),e("code",[t._v("node.raws")]),t._v(" object to store space symbol, etc.")]),t._v(" "),e("p",[t._v("All data related to source code and not CSS structure, should be in "),e("code",[t._v("Node#raws")]),t._v(". For instance, "),e("code",[t._v("postcss-scss")]),t._v(" keep in "),e("code",[t._v("Comment#raws.inline")]),t._v(" boolean marker of inline comment ("),e("code",[t._v("// comment")]),t._v(" instead of "),e("code",[t._v("/* comment */")]),t._v(").")]),t._v(" "),e("p",[t._v("Be careful, because sometimes these raw properties will not be present; some\nnodes may be built manually, or may lose their indentation when they are moved\nto another parent node.")]),t._v(" "),e("p",[t._v("This is why the default stringifier has a "),e("code",[t._v("raw()")]),t._v(" method to autodetect raw\nproperties by other nodes. For example, it will look at other nodes to detect\nindent size and them multiply it with the current node depth.")]),t._v(" "),e("h3",{attrs:{id:"tests-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tests-2"}},[t._v("#")]),t._v(" Tests")]),t._v(" "),e("p",[t._v("A stringifier must have tests too.")]),t._v(" "),e("p",[t._v("You can use unit and integration test cases from "),e("a",{attrs:{href:"https://github.com/postcss/postcss-parser-tests",target:"_blank",rel:"noopener noreferrer"}},[t._v("PostCSS Parser Tests"),e("OutboundLink")],1),t._v(".\nJust compare input CSS with CSS after your parser and stringifier.")])])}),[],!1,null,null,null);s.default=n.exports}}]);